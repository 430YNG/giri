#include <stdio.h>
#include <string.h>

FILE *out;
FILE *printInvOut;

#define MAX_FUNCTIONS 100
#define MAX_CALL_DEPTH 10000
#define MAX_CALLPATH 5
#define MIN(a,b) (a<b ? a : b)

struct Invariant {
  int Min;
  int Max;
  int FnId[MAX_CALLPATH]; // later add variables, operations, position/pgm point etc.
  int CallPathLength ;
  char *Fname;
};

int Stack[MAX_CALL_DEPTH] ;
int StackIndex = 0;
char *FNameStack[MAX_CALL_DEPTH] ;
int FNameStackIndex = 0;

struct Invariant *Map[MAX_FUNCTIONS][MAX_FUNCTIONS];
int MapIndex[MAX_FUNCTIONS];

int stackSize(void)
{
  return StackIndex;
}

int fNameStackSize(void)
{
  return FNameStackIndex;
}

void stackPop(void)
{
  //fprintf(stderr, "Inside stackPop\n"); 
  if( StackIndex == 0 )
    fprintf(stderr, "Empty function stack in invariant library\n");    
  else
    StackIndex--;
}

void fNameStackPop(void)
{
  //fprintf(stderr, "Inside fNameStackPop\n"); 
  if( FNameStackIndex == 0 )
    fprintf(stderr, "Empty function stack in invariant library\n");    
  else
    {
    FNameStackIndex--;
    free( FNameStack[FNameStackIndex] );
    }
}


void stackPush(int FunctionId)
{
  //fprintf(stderr, "Inside stackPush %d\n", FunctionId); 
  if( StackIndex > MAX_CALL_DEPTH )
    fprintf(stderr, "Full function stack in invariant library\n");    
  else
    Stack[StackIndex++] = FunctionId ;
}

void fNameStackPush(char *FunctionName)
{
  //fprintf(stderr, "Inside fNameStackPush %s\n", FunctionName); 
  if( FNameStackIndex > MAX_CALL_DEPTH )
    fprintf(stderr, "Full function stack in invariant library\n");    
  else
    {
    FNameStack[FNameStackIndex] = (char *) malloc( strlen(FunctionName) + 1 );
    strcpy( FNameStack[FNameStackIndex++] , FunctionName );
    }
}

int stackTop(int i)
{
  //fprintf(stderr, "Inside stackTop\n"); 
  if( StackIndex == 0 ||  StackIndex-1-i < 0 )
    fprintf(stderr, "Empty function stack in invariant library or access outside the stack \n");    
  else
    return Stack[StackIndex-1-i];
}

char *fNameStackTop(int i)
{
  //fprintf(stderr, "Inside fNameStackTop\n"); 
  if( FNameStackIndex == 0 ||  FNameStackIndex-1-i < 0 )
    fprintf(stderr, "Empty function stack in invariant library or access outside the stack \n");    
  else
    return FNameStack[FNameStackIndex-1-i];
}

void ddgtrace_init(const char *out_filename) {  
  int i;

  //fprintf(stderr, "Inside ddgtrace_init %s\n", out_filename); 
  out = fopen(out_filename, "w");
  for(i=0; i<MAX_FUNCTIONS; i++)
    MapIndex[i] = 0 ;
}

void trace_fn_start(int *FunctionId, char* FunctionName) {
  //fprintf(stderr, "Inside  trace_fn_start %d %s\n", *FunctionId, FunctionName); 
  if( *FunctionId > MAX_FUNCTIONS )
    fprintf(stderr, "Number of functions exceeds maximum number of allowed functions \n");        
  stackPush(*FunctionId);
  fNameStackPush(FunctionName);
  //fprintf(out, "%s %s\n", "FS", fname);
}

void trace_fn_end(int FunctionId) {
  //fprintf(stderr, "Inside  trace_fn_end\n"); 
  stackPop();
  fNameStackPop();
  //fprintf(out, "%s\n", "FE");
}

// return value will be the index of invariant, otherwise >= MapIndex[FunctionId]
int findInvariantEntry(int *callpath)
{
  int i=0, j=0, FnId = 0;
  fprintf(stderr, "Inside findInvariantEntry\n");   
  //fprintf(stderr, "Handling function id %d\n", callpath); 

  FnId = callpath[0];
  for(i=0; i<MapIndex[FnId]; i++)
     {
       for(j=0; j<Map[FnId][i]->CallPathLength; j++)
          if( Map[FnId][i]->FnId[j] != callpath[j] ) 
            break;
       if(j == Map[FnId][i]->CallPathLength) // Matchingvariant found
         break;
     }

  return i;
}

void trace_ret_value(signed value) {
  struct Invariant *inv;
  int i = 0, FnId = 0, InvIndex;
  int callpath[MAX_CALLPATH];
  char fname[100*MAX_CALLPATH];

  //fprintf(stderr, "Inside  trace_ret_value %d\n", value); 

  // Find out the entry in the map corresponding to current call path
  FnId = stackTop(0);
  for(i=0; i<MIN(MAX_CALLPATH,stackSize()); i++)
     callpath[i] = stackTop(i); 

  InvIndex = findInvariantEntry(callpath);

  if(InvIndex < MapIndex[FnId] ) // Invariant already exists
    {
     //fprintf(stderr, "Updating existing invarant\n"); 
     inv =  Map[FnId][InvIndex];
     if( inv->Min > value )
       {
       inv->Min = value;
       //fprintf(stderr, "Updating existing invarant\n"); 
       }

     if( inv->Max < value )
       {
       inv->Max = value;      
       //fprintf(stderr, "Updating existing invarant\n"); 
       }
 
    }
  else // Create a new Invariant
    {
     fprintf(stderr, "Creating new invarant\n"); 
     inv = (struct Invariant *) malloc(sizeof(struct Invariant));
     inv->Min = value;
     inv->Max = value;
     inv->CallPathLength = MIN(MAX_CALLPATH,stackSize());
     for(i=0; i<MIN(MAX_CALLPATH,stackSize()); i++)
        inv->FnId[i] = callpath[i];

     strcpy(fname, "");
     for(i=0; i<MIN(MAX_CALLPATH,fNameStackSize()); i++)
        strcat(fname, fNameStackTop(i)); 
     inv->Fname = (char *) malloc( strlen(fname) + 1 );
     strcpy( inv->Fname , fname );

     Map[FnId][MapIndex[FnId]] = inv;
     MapIndex[FnId]++; // Update the map index for current callpath
     if( MapIndex[FnId] > MAX_FUNCTIONS )
       fprintf(stderr, "Number of invarants exceeds maximum number allowed per function \n");        
    }
 
  //fprintf(out, "%s %d\n", fname, value);
}


void printInvariants( )
{
  int i = 0, j = 0, k = 0;
  //int callpath ;

  printInvOut = fopen("Invariants.txt", "w");

  fprintf(stderr, "Printing invariants\n"); 
  
  for(i=0; i<MAX_FUNCTIONS; i++)
     {
     fprintf(stderr, "%d %d\n", i, MapIndex[i]); 
     if( MapIndex[i] != 0 )
       {
        fprintf(printInvOut, "%d %d\n", i, MapIndex[i]); 
        for(j=0; j<MapIndex[i]; j++)
           {
            fprintf(printInvOut, "%d ", Map[i][j]->CallPathLength);
            for(k=0; k< Map[i][j]->CallPathLength; k++)
	      fprintf(printInvOut, "%d ", Map[i][j]->FnId[k]);
            fprintf(printInvOut, "%s %d %d\n", Map[i][j]->Fname, Map[i][j]->Min, Map[i][j]->Max); 
           }
       }
     }
  //fflush(out);
  fprintf(stderr, "Finished printing invariants\n"); 
}

void check_invariant(int return_value, int *min, int *max)
{
  //assert (return_value >= min) ;
  //printf("%d %d\n", *min, *max);
  if( (return_value < (int)(*min)) || (return_value > (int)(*max)) )
    {
     fprintf(stderr, "Exiting through invariant failure\n");      
     exit(100);
    }
}

void __main()
{
}


/*
#include <stdio.h>

FILE *out;

void ddgtrace_init(const char *out_filename) {
  out = fopen(out_filename, "w");
}

void trace_fn_start(char *fname) {
  fprintf(out, "%s %s\n", "FS", fname);
}

void trace_fn_end(char *fname) {
  fprintf(out, "%s\n", "FE");
}

void trace_ret_value(signed value) {
  fprintf(out, "%s %d\n", "RV", value);
}


void check_invariant(int return_value, int *min, int *max)
{
  //assert (return_value >= min) ;
  //printf("%d %d\n", *min, *max);
  if( (return_value < (int)(*min)) || (return_value > (int)(*max)) )
    exit(100);
}

void __main()
{
}
*/
