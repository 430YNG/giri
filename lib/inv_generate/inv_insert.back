//===----------- inv_insert.cpp - Insert invariant checks into the code ------------===//
// 
//                     The LLVM Compiler Infrastructure
//
// This file was developed by the LLVM research group and is distributed under
// the University of Illinois Open Source License. See LICENSE.TXT for details.
// 
//===----------------------------------------------------------------------===//
//
// This file uses the invariants generated by the inv_generate
// instrumentation, together with the LLVM program, to generate a
// code with invariant checks inserted.
//
//===----------------------------------------------------------------------===//

#define DEBUG_TYPE "inv-insert"

#include "llvm/Analysis/LoopInfo.h"
#include "llvm/Constants.h"
#include "llvm/DerivedTypes.h"
#include "llvm/Function.h"
#include "llvm/Instructions.h"
#include "llvm/Pass.h"
#include "llvm/Type.h"
#include "llvm/DerivedTypes.h"
#include "llvm/Transforms/Scalar.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/Debug.h"
#include <ext/hash_map>
#include <ext/hash_set>
#include "llvm/ADT/STLExtras.h"
#include "llvm/Support/InstVisitor.h"
#include "BasicBlockNumbering.h"
#include "Utils.h"

#include <list>
#include <stack>
#include <vector>
#include <string>
#include <fstream>

using namespace llvm;

namespace llvm {
  cl::opt<bool> NOEXIT_IN_INV("NOEXIT_IN_INV", cl::desc("Disable exit on invariant failure"));
  cl::opt<bool> ONE_LEVEL_INV("ONE_LEVEL_INV", cl::desc("Use only one level of invariants"));
  cl::opt<bool> NO_UNSIGNED_CHECK("NO_UNSIGNED_CHECK", cl::desc("No Invariants on unsigned values"));
  cl::opt<bool> NO_FLOAT_CHECK("NO_FLOAT_CHECK", cl::desc("No Invariants on floating point values"));
}

namespace {

  #include "defs.h"

  //===----------------------------------------------------------------------===//
  //                          Class definitions
  //===----------------------------------------------------------------------===//

  //#define MAX_CALLPATH_LENGTH 1
  #define MIN(a,b) (a<b ? a : b)

  typedef hash_map<int,Invariant*> InvMap;  
  //typedef std::string CallPath [MAX_CALLPATH_LENGTH];

  class InvInsert : public FunctionPass, public InstVisitor<InvInsert> {

  public:

    bool runOnFunction(Function &F);
    bool CheckType(const Type *T);
    bool doInitialization(Module &M);
    bool doFinalization(Module &M);
    void printInvariants(InvMap &iMap);
    void mydebug(const Type *T);

    void getAnalysisUsage(AnalysisUsage &AU) const {
      AU.addRequired<LoopInfo>();
    }

  private:

    Module *theModule;
    std::ifstream *aggressiveInvInpFile, *conservativeInvInpFile;
    InvMap aggressiveInvMap, conservativeInvMap;
    /*    GlobalVariable *longMin, *longMax, *PgmPtId ;
    GlobalVariable *intMin, *intMax ;
    GlobalVariable *shortMin, *shortMax ;*/
    /* ConstantInt *shortMin, *shortMax, *intMin, *intMax, *longMin, *longMax, *PgmPtId; */
    ConstantInt *SIntMin, *SIntMax, *UIntMin, *UIntMax, *PgmPtId;
    ConstantFP *FPMin, *FPMax ;
    ConstantInt *AggrSIntMin, *AggrSIntMax, *AggrUIntMin, *AggrUIntMax, *AggrPgmPtId;
    ConstantFP *AggrFPMin, *AggrFPMax ;
    int ProgramPtId;
    bool Changed;

    void readInvariants(InvMap &iMap, std::ifstream *); 
    CallInst *insertCheckCall(Instruction *, Value *);
    std::map<const Type*, std::string> CheckCallMap;
    void scheduleInit(void);
   }; 

  RegisterPass<InvInsert> X("inv-insert",
			  "Insert invariant checks into the code");

}


//===----------------------------------------------------------------------===//
//                     InvInsert implementation
//===----------------------------------------------------------------------===//

bool InvInsert::doInitialization(Module &M) {
  ProgramPtId = 0;
  Changed = false ;
  theModule = &M;
  conservativeInvInpFile = new std::ifstream("Invariants.txt");
  if (!conservativeInvInpFile) {
    std::cerr << "Error opening trace file!\n";
    exit(1);
  }
  readInvariants(conservativeInvMap, conservativeInvInpFile);

  aggressiveInvInpFile = new std::ifstream("Invariants-aggressive.txt");
  if (!aggressiveInvInpFile) {
    std::cerr << "Error opening trace file!\n";
    exit(1);
  }
  readInvariants(aggressiveInvMap, aggressiveInvInpFile);
  
  /*** Create the check call mapping ****/
  CheckCallMap[Type::LongTy]   = "check_invariant_long";
  CheckCallMap[Type::IntTy]    = "check_invariant_int";
  CheckCallMap[Type::ShortTy]  = "check_invariant_short";
  CheckCallMap[Type::SByteTy]  = "check_invariant_char";
  CheckCallMap[Type::ULongTy]  = "check_invariant_ulong";
  CheckCallMap[Type::UIntTy]   = "check_invariant_uint";
  CheckCallMap[Type::UShortTy] = "check_invariant_ushort";
  CheckCallMap[Type::UByteTy]  = "check_invariant_uchar";
  CheckCallMap[Type::FloatTy]  = "check_invariant_float";
  CheckCallMap[Type::DoubleTy] = "check_invariant_double";

  /*** Finished creating the mapping ****/

  return false;
}

bool  InvInsert::CheckType(const Type *T) {
  if( T == Type::LongTy || T == Type::IntTy || T == Type::ShortTy || T == Type::SByteTy )
    return true;
  if( !NO_UNSIGNED_CHECK )
    if( T == Type::ULongTy || T == Type::UIntTy || T == Type::UShortTy || T == Type::UByteTy )
      return true; 
  if( !NO_FLOAT_CHECK )
    if( T == Type::FloatTy || T == Type::DoubleTy )
      return true;
 
  return false;
}

CallInst *InvInsert::insertCheckCall(Instruction *Inst, Value *val)
{
  CallInst *CI = NULL;

  const Type *T = val->getType();
  if( T->isSigned() ) 
    {
     SIntMin = ConstantInt::get(T, conservativeInvMap[ProgramPtId]->Min.longMin);
     SIntMax = ConstantInt::get(T, conservativeInvMap[ProgramPtId]->Max.longMax);
     if( ONE_LEVEL_INV )
       CI = getCallInst(Type::VoidTy, CheckCallMap[T], val, SIntMin, SIntMax, PgmPtId, "", Inst);
     else
       {
        if( aggressiveInvMap.count(ProgramPtId) != 0 ) // If aggressive invariant exists
          {
            AggrSIntMin = ConstantInt::get(T, aggressiveInvMap[ProgramPtId]->Min.longMin);
            AggrSIntMax = ConstantInt::get(T, aggressiveInvMap[ProgramPtId]->Max.longMax);
	  }
        else
          {
	    AggrSIntMin = SIntMin;
	    AggrSIntMax = SIntMax;
          }
        CI = getCallInst(Type::VoidTy, CheckCallMap[T], val, SIntMin, SIntMax, AggrSIntMin, AggrSIntMax, PgmPtId, "", Inst);
       }
    }
  else if( T->isUnsigned() ) 
    {
     UIntMin = ConstantInt::get(T, conservativeInvMap[ProgramPtId]->Min.ulongMin);
     UIntMax = ConstantInt::get(T, conservativeInvMap[ProgramPtId]->Max.ulongMax);
     if( ONE_LEVEL_INV )
       CI = getCallInst(Type::VoidTy, CheckCallMap[T], val, UIntMin, UIntMax, PgmPtId, "", Inst);
     else
       {
        if( aggressiveInvMap.count(ProgramPtId) != 0 ) // If aggressive invariant exists
          {
            AggrUIntMin = ConstantInt::get(T, aggressiveInvMap[ProgramPtId]->Min.ulongMin);
            AggrUIntMax = ConstantInt::get(T, aggressiveInvMap[ProgramPtId]->Max.ulongMax);
          }
        else
          {
	    AggrUIntMin = UIntMin;
	    AggrUIntMax = UIntMax;
          }
        //DEBUG( std::cerr << conservativeInvMap[ProgramPtId]->Min.ulongMin << " " << conservativeInvMap[ProgramPtId]->Max.ulongMax << " " );
        //DEBUG( std::cerr << aggressiveInvMap[ProgramPtId]->Min.ulongMin << " " << aggressiveInvMap[ProgramPtId]->Max.ulongMax << " " );
        CI = getCallInst(Type::VoidTy, CheckCallMap[T], val,UIntMin, UIntMax, AggrUIntMin, AggrUIntMax, PgmPtId, "", Inst);
       }
    }
  else if( T->isFloatingPoint() )
    {
     FPMin = ConstantFP::get(T, conservativeInvMap[ProgramPtId]->Min.doubleMin);
     FPMax = ConstantFP::get(T, conservativeInvMap[ProgramPtId]->Max.doubleMax);
     if( ONE_LEVEL_INV )
       CI = getCallInst(Type::VoidTy, CheckCallMap[T], val, FPMin, FPMax, PgmPtId, "", Inst);
     else
       {
        if( aggressiveInvMap.count(ProgramPtId) != 0 ) // If aggressive invariant exists
          {
            AggrFPMin = ConstantFP::get(T, aggressiveInvMap[ProgramPtId]->Min.doubleMin);
            AggrFPMax = ConstantFP::get(T, aggressiveInvMap[ProgramPtId]->Max.doubleMax);
          }
        else
          {
	    AggrFPMin = FPMin;
	    AggrFPMax = FPMax;
          }
        CI = getCallInst(Type::VoidTy, CheckCallMap[T], val, FPMin, FPMax, AggrFPMin, AggrFPMax, PgmPtId, "", Inst);
       }
    }

  return CI;
}

#define DEBUG_PRINT(TYPE) \
    {  \
      DEBUG( std::cerr << ProgramPtId << " "  << conservativeInvMap[ProgramPtId]->Min.TYPE##Min << " " << conservativeInvMap[ProgramPtId]->Max.TYPE##Max << "\n" ) ;  \
    }

void InvInsert::mydebug(const Type *T)
{                  
  if( T->isSigned() ) 
    { DEBUG_PRINT( long ) }
  else if( T->isUnsigned() ) 
    { DEBUG_PRINT( ulong ) }
  else if( T->isFloatingPoint() )
    { DEBUG_PRINT( double ) }
}

bool InvInsert::runOnFunction(Function &F) {
  DEBUG( std::cerr << "Inside Function: " << F.getName() << "\n" );
  if (F.getName() == "main") 
    {
      if( NOEXIT_IN_INV )
       {  
        getCallInst(Type::VoidTy, "disable_exit_in_inv", "", F.getEntryBlock().begin());
       }       
      getCallInst(Type::VoidTy, "init_check_invariant", "", F.getEntryBlock().begin());
      getCallInst(Type::VoidTy, "output_inv_addr", "", F.getEntryBlock().begin());
    } 

  for( Function::iterator FI = F.begin(); FI != F.end(); FI++ )
     {
      for( BasicBlock::iterator BI = FI->begin(); BI != FI->end(); BI++ ) 
         {  
           Value *CheckVal;

           if( ReturnInst *RetInst = dyn_cast<ReturnInst>(BI) ) 
             {
               DEBUG( std::cerr << "Handling return instruction \n" );
               CheckVal = RetInst->getReturnValue();

               // Process non-void observed functions which have interger return values
               if( CheckVal != NULL ) // && conservativeInvMap.count(ProgramPtId) != 0 )
                 {
                  DEBUG( std::cerr << "Handling non-void Function \n" );
                  
                  if( CheckType(CheckVal->getType()) && isa_impl<Constant, Value>(*CheckVal) == false )
                    {/* If its a proper type for tracing and not a constant */ 
                     if( conservativeInvMap.count(ProgramPtId) != 0 ) // can be 0 when corresponding return/load/store instruction
                       {                                // never executes
                        DEBUG( std::cerr << "Handling non-void signed/unsigned/FP returning Function \n" );
                        mydebug( CheckVal->getType() );

                        PgmPtId = ConstantInt::get(Type::IntTy, conservativeInvMap[ProgramPtId]->ProgramPtId);                            
                        insertCheckCall(RetInst, CheckVal);

                        Changed = true;
			}
                     ProgramPtId++;  // Update the id for the next program popint
		    }
                 }
             }
           
           else if( StoreInst *StInst = dyn_cast<StoreInst>(BI) ) 
             {
               DEBUG( std::cerr << "Handling store instruction \n" );
               CheckVal = StInst->getOperand(0);  // Get value operand               
               // Process Integer stores
               
               if( CheckType(CheckVal->getType()) && isa_impl<Constant, Value>(*CheckVal) == false )
                 {
                  if( conservativeInvMap.count(ProgramPtId) != 0 ) // can be 0 when corresponding return/load/store instruction
                    {                                // never executes
                     DEBUG( std::cerr << "Handling signed/unsigned/FP stores \n" );
                     mydebug( CheckVal->getType() );

                     PgmPtId = ConstantInt::get(Type::IntTy, conservativeInvMap[ProgramPtId]->ProgramPtId);       
                     insertCheckCall(StInst, CheckVal);

                     Changed = true;
		     }
                  ProgramPtId++;  // Update the id for the next program popint
		  }
             }

           else if( LoadInst *LdInst = dyn_cast<LoadInst>(BI) ) 
             {
               DEBUG( std::cerr << "Handling load instruction \n" );
               CheckVal = LdInst;  // Get value operand               
               // Process Integer stores
               
               if( CheckType(CheckVal->getType()) && isa_impl<Constant, Value>(*CheckVal) == false ) 
                 {
                  if( conservativeInvMap.count(ProgramPtId) != 0 ) // can be 0 when corresponding return/load/store instruction
                    {                                // never executes
                     DEBUG( std::cerr << "Handling signed/unsigned/FP loads \n" );
                     mydebug( CheckVal->getType() );    

                     PgmPtId = ConstantInt::get(Type::IntTy, conservativeInvMap[ProgramPtId]->ProgramPtId);       
                     CallInst *CI = insertCheckCall(LdInst, CheckVal);
                     LdInst->moveBefore(CI);

                     Changed = true;
		     }
                  ProgramPtId++;  // Update the id for the next program popint
		  }
             }
	     
         }
     }  


  return Changed;
}

bool InvInsert::doFinalization(Module &M) {
  return false;
}



/********************************************************/
/***************** Swarup's code ************************/
/********************************************************/

#define READ_INVARIANT(INPFILE , INVMAP , TYPE) \
        {                             \
         INPFILE >> INVMAP[InvIndex]->Count >>  INVMAP[InvIndex]->NoOfUpdation >>  INVMAP[InvIndex]->Change.TYPE##Change   \
                                          >>  INVMAP[InvIndex]->DetailedType >>  INVMAP[InvIndex]->InstName  ;             \
         INPFILE >> INVMAP[InvIndex]->ProgramPtId ;  /* Should be changed to key of the new hashing function */              \
         INPFILE >> fname >> INVMAP[InvIndex]->Min.TYPE##Min >> INVMAP[InvIndex]->Max.TYPE##Max ;   \
	}

void InvInsert::readInvariants(InvMap &iMap, std::ifstream *InpInvFile)
{
  int count, InvIndex;
  int j = 0;
  char fname[100];

  while( (*InpInvFile >> InvIndex) ) 
      {
        *InpInvFile >> count;
        for(j=0; j<count; j++)
           { //***** Now count = 1. Use a different hashing function, if count > 1 *******
            iMap[InvIndex] = new Invariant ; 
	    *InpInvFile >> iMap[InvIndex]->Type ;

            if( !strcmp(iMap[InvIndex]->Type, "long") )  
               READ_INVARIANT(*InpInvFile, iMap, long)
            else if( !strcmp(iMap[InvIndex]->Type, "ulong") )  
               READ_INVARIANT(*InpInvFile, iMap, ulong)
            else if( !strcmp(iMap[InvIndex]->Type, "double") )  
	       READ_INVARIANT(*InpInvFile, iMap,long) /* Reading as long to avoid truncation */

            iMap[InvIndex]->Fname = (char *) malloc( strlen(fname) + 1 );
            strcpy( iMap[InvIndex]->Fname , fname );
           }
      } 
  printInvariants(iMap);   
}

#define PRINT_INVARIANT(TYPE) \
           {                                                           \
            DEBUG( std::cerr << it->first << " " << it->second->Type << " " << it->second->Count << " " <<  it->second->NoOfUpdation << " " << \
                              it->second->Change.TYPE##Change << " " << it->second-> DetailedType << " " <<  it->second->InstName << "\n" ) ;  \
            DEBUG( std::cerr << it->second->ProgramPtId << " " << it->second->Fname << " " << it->second->Min.TYPE##Min << " " << it->second->Max.TYPE##Max << "\n" ) ; \
           }         

void InvInsert::printInvariants(InvMap &iMap)
{
  DEBUG( std::cerr << "Printing invariants\n" ) ; 
  for( InvMap::iterator it = iMap.begin(); it != iMap.end(); it++ )
     {
       if( !strcmp(it->second->Type,"long") )  
         PRINT_INVARIANT(long)
       else if( !strcmp(it->second->Type,"ulong") )  
         PRINT_INVARIANT(ulong)
       else if( !strcmp(it->second->Type,"double") )  
         PRINT_INVARIANT(long)  /* printing as long to avoid truncation */
     }
  DEBUG( std::cerr << "Finished printing invariants\n" ) ; 
}



void InvInsert::scheduleInit(void)
{

}

