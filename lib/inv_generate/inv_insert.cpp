//===----------- inv_insert.cpp - Insert invariant checks into the code ------------===//
// 
//                     The LLVM Compiler Infrastructure
//
// This file was developed by the LLVM research group and is distributed under
// the University of Illinois Open Source License. See LICENSE.TXT for details.
// 
//===----------------------------------------------------------------------===//
//
// This file uses the invariants generated by the inv_generate
// instrumentation, together with the LLVM program, to generate a
// code with invariant checks inserted.
//
//===----------------------------------------------------------------------===//

#define DEBUG_TYPE "inv-insert"

#include "inv/inv_generate.h"
#include "diagnosis/BasicBlockNumbering.h"
#include "diagnosis/LoadStoreNumbering.h"
#include "diagnosis/Utils.h"
#include "inv/inv_utils.h"

#include "llvm/Analysis/LoopInfo.h"
#include "llvm/Constants.h"
#include "llvm/DerivedTypes.h"
#include "llvm/Function.h"
#include "llvm/Instructions.h"
#include "llvm/Pass.h"
#include "llvm/Type.h"
#include "llvm/DerivedTypes.h"
#include "llvm/Transforms/Scalar.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/Debug.h"
#include <ext/hash_map>
#include <ext/hash_set>
#include "llvm/ADT/STLExtras.h"
#include "llvm/Support/InstVisitor.h"
#include "BasicBlockNumbering.h"

#include <list>
#include <stack>
#include <vector>
#include <string>
#include <fstream>

using namespace llvm;

namespace llvm {
  cl::opt<bool> NOEXIT_IN_INV("NOEXIT_IN_INV", cl::desc("Disable exit on invariant failure"));
  cl::opt<bool> ONE_LEVEL_INV("ONE_LEVEL_INV", cl::desc("Use only one level of invariants"));
  cl::opt<bool> NO_UNSIGNED_CHECK("NO_UNSIGNED_CHECK", cl::desc("No Invariants on unsigned values"));
  cl::opt<bool> NO_FLOAT_CHECK("NO_FLOAT_CHECK", cl::desc("No Invariants on floating point values"));
}

//namespace {

//  #include "defs.h"

  //===----------------------------------------------------------------------===//
  //                          Class definitions
  //===----------------------------------------------------------------------===//

  //#define MAX_CALLPATH_LENGTH 1
  #define MIN(a,b) (a<b ? a : b)

  typedef hash_map<int,Invariant*> InvMap;  
  //typedef std::string CallPath [MAX_CALLPATH_LENGTH];

  class InvInsert : public FunctionPass, public InstVisitor<InvInsert> {

  public:
    static char ID;
    InvInsert() : FunctionPass (ID) {}

    bool runOnFunction(Function &F);
    bool CheckType(const Type *T);
    bool doInitialization(Module &M);
    bool doFinalization(Module &M);
    //void printInvariants(InvMap &iMap);
    void mydebug(const Type *T);

    void getAnalysisUsage(AnalysisUsage &AU) const {
        AU.addRequired<QueryBasicBlockNumbers>();
        AU.addPreserved<QueryBasicBlockNumbers>();

        AU.addRequired<QueryLoadStoreNumbers>();
        AU.addPreserved<QueryLoadStoreNumbers>(); 
    }

  private:
    // Pointers to other passes
    const QueryBasicBlockNumbers * bbNumPass;
    const QueryLoadStoreNumbers  * lsNumPass;

    Module *theModule;
    std::ifstream *invInpFile;
    InvMap invMap;
    /*    GlobalVariable *longMin, *longMax, *PgmPtId ;
    GlobalVariable *intMin, *intMax ;
    GlobalVariable *shortMin, *shortMax ;*/
    /* ConstantInt *shortMin, *shortMax, *intMin, *intMax, *longMin, *longMax, *PgmPtId; */
    ConstantInt *SIntMin, *SIntMax, *UIntMin, *UIntMax, *PgmPtId;
    ConstantFP *FPMin, *FPMax ;
    ConstantInt *AggrSIntMin, *AggrSIntMax, *AggrUIntMin, *AggrUIntMax, *AggrPgmPtId;
    ConstantFP *AggrFPMin, *AggrFPMax ;
    unsigned ProgramPtId;
    bool Changed;

    //void readInvariants(InvMap &iMap, std::ifstream *); 
    CallInst *insertCheckCall(Instruction *, Value *);
    std::map<const Type*, std::string> CheckCallMap;
    //void scheduleInit(void);

    // Type Variables
    const Type *SInt64Ty, *SInt32Ty, *SInt16Ty, *SInt8Ty, *UInt64Ty, *UInt32Ty, *UInt16Ty, *UInt8Ty, *FloatTy, *DoubleTy, *VoidTy;
    IntegerType *IntTy; // For creating 32-bit integer constants for program instrumentation

   // Private methods
   Function * createCtor (Module & M);
   void insertIntoGlobalCtorList (Function * RuntimeCtor);

   }; 

  // Pass registration
  static RegisterPass<InvInsert> X("inv-insert",
			  "Insert invariant checks into the code");

//}

// ID Variable to identify the pass
char InvInsert::ID = 0;

//===----------------------------------------------------------------------===//
//                     InvInsert implementation
//===----------------------------------------------------------------------===//

//
// Function: createCtor()
//
// Description:
//  Create a global constructor (ctor) function that can be called when the
//  program starts up.
//
//
Function *
InvInsert::createCtor (Module & M) {
  //
  // Create the ctor function.
  //
  Type * VoidTy = Type::getVoidTy (M.getContext());
  Function * RuntimeCtor = dyn_cast<Function>(M.getOrInsertFunction ("giriInvInsertCtor", VoidTy, NULL));
  assert (RuntimeCtor && "Somehow created a non-function function!\n");

  //
  // Make the ctor function internal and non-throwing.
  //
  RuntimeCtor->setDoesNotThrow();
  RuntimeCtor->setLinkage(GlobalValue::InternalLinkage);

  //
  // Add a call in the new constructor function to the Giri initialization
  // function.
  //
  BasicBlock * BB = BasicBlock::Create (M.getContext(), "entry", RuntimeCtor);
  //Constant * Name = stringToGV (TraceFilename, &M);
  //Name = ConstantExpr::getZExtOrBitCast (Name, VoidPtrType);
  //CallInst::Create (Init, Name, "", BB);

  if( NOEXIT_IN_INV )
    {  
      getCallInst(VoidTy, "inv_disable_exit_in_inv", "", BB);
    }       
  getCallInst(VoidTy, "inv_invcheck_init", "", BB);

  //
  // Add a return instruction at the end of the basic block.
  //
  ReturnInst::Create (M.getContext(), BB);
  return RuntimeCtor;
}

//
// Method: insertIntoGlobalCtorList()
//ss
// Description:
//  Insert the specified function into the list of global constructor
//  functions.
//
void
InvInsert::insertIntoGlobalCtorList (Function * RuntimeCtor) {
  //
  // Insert the run-time ctor into the ctor list.
  //
  LLVMContext & Context = RuntimeCtor->getParent()->getContext();
  Type * Int32Type = IntegerType::getInt32Ty (Context);
  std::vector<Constant *> CtorInits;
  CtorInits.push_back (ConstantInt::get (Int32Type, 65535));
  CtorInits.push_back (RuntimeCtor);
  //Constant * RuntimeCtorInit=ConstantStruct::get(Context,CtorInits, false);
  Constant * RuntimeCtorInit=ConstantStruct::getAnon(Context,CtorInits, false);

  //
  // Get the current set of static global constructors and add the new ctor
  // to the list.
  //
  std::vector<Constant *> CurrentCtors;
  Module & M = *(RuntimeCtor->getParent());
  GlobalVariable * GVCtor = M.getNamedGlobal ("llvm.global_ctors");
  if (GVCtor) {
    if (Constant * C = GVCtor->getInitializer()) {
      for (unsigned index = 0; index < C->getNumOperands(); ++index) {
        CurrentCtors.push_back (cast<Constant>(C->getOperand (index)));
      }
    }

    //
    // Rename the global variable so that we can name our global
    // llvm.global_ctors.
    //
    GVCtor->setName ("removed");
  }

  //
  // The ctor list seems to be initialized in different orders on different
  // platforms, and the priority settings don't seem to work.  Examine the
  // module's platform string and take a best guess to the order.
  //
  if (M.getTargetTriple().find ("linux") == std::string::npos)
    CurrentCtors.insert (CurrentCtors.begin(), RuntimeCtorInit);
  else
    CurrentCtors.push_back (RuntimeCtorInit);

  //
  // Create a new initializer.
  //
  ArrayType * AT = ArrayType::get (RuntimeCtorInit-> getType(),
                                         CurrentCtors.size());
  Constant * NewInit=ConstantArray::get (AT, CurrentCtors);

  //
  // Create the new llvm.global_ctors global variable and replace all uses of
  // the old global variable with the new one.
  //
  new GlobalVariable (M,
                      NewInit->getType(),
                      false,
                      GlobalValue::AppendingLinkage,
                      NewInit,
                      "llvm.global_ctors");
}


bool InvInsert::doInitialization(Module &M) {
  ProgramPtId = 0;
  Changed = false ;
  theModule = &M;
  invInpFile = new std::ifstream("Invariants.txt");
  if (!invInpFile) {
    std::cerr << "Error opening generated invariants file!\n";
    exit(1);
  }
  readInvariants(invMap, invInpFile);
  
  /*** Create the type variables ***/
  ////////////////////  Right now treat all unsigned values as signed
  
  UInt64Ty = Type::getInt64Ty(M.getContext());
  UInt32Ty = Type::getInt32Ty(M.getContext());
  UInt16Ty = Type::getInt16Ty(M.getContext());
  UInt8Ty  = Type::getInt8Ty(M.getContext());
  
  SInt64Ty = Type::getInt64Ty(M.getContext());
  SInt32Ty = Type::getInt32Ty(M.getContext());
  SInt16Ty = Type::getInt16Ty(M.getContext());
  SInt8Ty  = Type::getInt8Ty(M.getContext());
  FloatTy  = Type::getFloatTy(M.getContext());
  DoubleTy = Type::getDoubleTy(M.getContext());
  VoidTy = Type::getVoidTy(M.getContext());
  IntTy = IntegerType::get(M.getContext(), 32);

  /*** Create the trace call mapping ****/
  /* // Now in LLVM signed/unsigned values are same type
  CheckCallMap[UInt64Ty]  = "inv_check_invariant_ulong";
  CheckCallMap[UInt32Ty]  = "inv_check_invariant_uint";
  CheckCallMap[UInt16Ty]  = "inv_check_invariant_ushort";
  CheckCallMap[UInt8Ty]   = "inv_check_invariant_uchar";
  */
  CheckCallMap[SInt64Ty]  = "inv_check_invariant_long";
  CheckCallMap[SInt32Ty]  = "inv_check_invariant_int";
  CheckCallMap[SInt16Ty]  = "inv_check_invariant_short";
  CheckCallMap[SInt8Ty]   = "inv_check_invariant_char";
  CheckCallMap[FloatTy]   = "inv_check_invariant_float";
  CheckCallMap[DoubleTy]  = "inv_check_invariant_double";

  /*** Finished creating the mapping ****/

  /*
  CheckCallMap[Type::LongTy]   = "inv_check_invariant_long";
  CheckCallMap[Type::IntTy]    = "inv_check_invariant_int";
  CheckCallMap[Type::ShortTy]  = "inv_check_invariant_short";
  CheckCallMap[Type::SByteTy]  = "inv_check_invariant_char";
  CheckCallMap[Type::ULongTy]  = "inv_check_invariant_ulong";
  CheckCallMap[Type::UIntTy]   = "inv_check_invariant_uint";
  CheckCallMap[Type::UShortTy] = "inv_check_invariant_ushort";
  CheckCallMap[Type::UByteTy]  = "inv_check_invariant_uchar";
  CheckCallMap[Type::FloatTy]  = "inv_check_invariant_float";
  CheckCallMap[Type::DoubleTy] = "inv_check_invariant_double";
  */

  return false;
}

bool  InvInsert::CheckType(const Type *T) {
  if( T == SInt64Ty || T == SInt32Ty || T == SInt16Ty || T == SInt8Ty )
    return true;
  if( !NO_UNSIGNED_CHECK )
    if( T == UInt64Ty || T == UInt32Ty || T == SInt16Ty || T == SInt8Ty )
      return true; 
  if( !NO_FLOAT_CHECK )
    if( T == FloatTy || T == DoubleTy )
      return true;
 
  return false;
}

CallInst *InvInsert::insertCheckCall(Instruction *Inst, Value *val)
{
  CallInst *CI = NULL;
  Type *T = val->getType();

  //ProgramPtId = lsNumPass->getID (Inst);
  //std::cerr << invMap[ProgramPtId]->ProgramPtId << std::endl;
  PgmPtId = ConstantInt::get(IntTy, invMap[ProgramPtId]->ProgramPtId);                            

  if( CheckType(T) ) 
    {
      if( T->isIntegerTy() ) // Currently treat signed and unsigned uniformly as signed: !!!!!!FIX IT!!!!!!
        {
	 IntegerType *TempIntTy = dyn_cast<IntegerType>(T);
         SIntMin = ConstantInt::get(TempIntTy, invMap[ProgramPtId]->Min.longMin, true); // Use false for unsigned
         SIntMax = ConstantInt::get(TempIntTy, invMap[ProgramPtId]->Max.longMax, true);
         CI = getCallInst(VoidTy, CheckCallMap[T], val, SIntMin, SIntMax, PgmPtId, "", Inst);
	}
      else if( T->isFloatingPointTy() )
        {
	 APFloat FV1(invMap[ProgramPtId]->Min.doubleMin);
	 APFloat FV2(invMap[ProgramPtId]->Max.doubleMax);
         FPMin = ConstantFP::get(Inst->getContext(), FV1);
         FPMax = ConstantFP::get(Inst->getContext(), FV2);
         CI = getCallInst(VoidTy, CheckCallMap[T], val, FPMin, FPMax, PgmPtId, "", Inst);
	}
      else
        DEBUG( std::cerr <<"Encountered a type not handled currently in our code" << std::endl );
    }

  /*
  if( T->isSigned() ) 
    {
     SIntMin = ConstantInt::get(T, conservativeInvMap[ProgramPtId]->Min.longMin);
     SIntMax = ConstantInt::get(T, conservativeInvMap[ProgramPtId]->Max.longMax);
     if( ONE_LEVEL_INV )
       CI = getCallInst(VoidTy, CheckCallMap[T], val, SIntMin, SIntMax, PgmPtId, "", Inst);
    }
  
  else if( T->isUnsigned() ) 
    {
     UIntMin = ConstantInt::get(T, conservativeInvMap[ProgramPtId]->Min.ulongMin);
     UIntMax = ConstantInt::get(T, conservativeInvMap[ProgramPtId]->Max.ulongMax);
     if( ONE_LEVEL_INV )
       CI = getCallInst(VoidTy, CheckCallMap[T], val, UIntMin, UIntMax, PgmPtId, "", Inst);
    }
  
  else if( T->isFloatingPoint() )
    {
     FPMin = ConstantFP::get(T, conservativeInvMap[ProgramPtId]->Min.doubleMin);
     FPMax = ConstantFP::get(T, conservativeInvMap[ProgramPtId]->Max.doubleMax);
     if( ONE_LEVEL_INV )
       CI = getCallInst(VoidTy, CheckCallMap[T], val, FPMin, FPMax, PgmPtId, "", Inst);
    }
  */

  return CI;
}

#define DEBUG_PRINT(TYPE) \
    {  \
      DEBUG( std::cerr << ProgramPtId << " "  << invMap[ProgramPtId]->Min.TYPE##Min << " " << invMap[ProgramPtId]->Max.TYPE##Max << "\n" ) ;  \
    }

void InvInsert::mydebug(const Type *T)
{                  
  if(  T->isIntegerTy() ) // Currently treat signed and unsigned uniformly as signed: !!!!!!FIX IT!!!!!! 
    { DEBUG_PRINT( long ) }
  else if( T->isFloatingPointTy() )
    { DEBUG_PRINT( double ) }
  /*
  if( T->isSigned() ) 
    { DEBUG_PRINT( long ) }
  else if( T->isUnsigned() ) 
    { DEBUG_PRINT( ulong ) }
  else if( T->isFloatingPoint() )
    { DEBUG_PRINT( double ) }
  */
}

bool InvInsert::runOnFunction(Function &F) {
  
  // Get the Basic Block and Load Store numberings
  // Will be run once per module
  bbNumPass = &getAnalysis<QueryBasicBlockNumbers>();
  lsNumPass = &getAnalysis<QueryLoadStoreNumbers>();

  DEBUG( std::cerr << "Inside Function: " << F.getName().str() << std::endl );

  /*
  // Now being done in a constructor
  if (F.getName() == "main") 
    {
      if( NOEXIT_IN_INV )
       {  
        getCallInst(VoidTy, "inv_disable_exit_in_inv", "", F.getEntryBlock().begin());
       }       
      getCallInst(VoidTy, "inv_invcheck_init", "", F.getEntryBlock().begin());
    } 
  */

  for( Function::iterator FI = F.begin(); FI != F.end(); FI++ )
     {
      for( BasicBlock::iterator BI = FI->begin(); BI != FI->end(); BI++ ) 
         {  
           Value *CheckVal;
          
           ProgramPtId = lsNumPass->getID (BI);

          // Don't trace individual returns as we are tracking function calls
	   /*
           if( ReturnInst *RetInst = dyn_cast<ReturnInst>(BI) ) 
             {
               DEBUG( std::cerr << "Handling return instruction \n" );
               CheckVal = RetInst->getReturnValue();

               // Process non-void observed functions which have interger return values
               if( CheckVal != NULL ) // && conservativeInvMap.count(ProgramPtId) != 0 )
                 {
                  DEBUG( std::cerr << "Handling non-void Function \n" );
                  
                  //ProgramPtId++;  // Update the id for the next program popint
                  if( CheckType(CheckVal->getType()) && isa_impl<Constant, Value>(*CheckVal) == false )
                    {// If its a proper type for tracing and not a constant 
                     if( invMap.count(ProgramPtId) != 0 ) // can be 0 when corresponding return/load/store instruction
                       {                                              // never executes
                        DEBUG( std::cerr << "Handling non-void signed/unsigned/FP returning Function \n" );
                        mydebug( CheckVal->getType() );

                        insertCheckCall(RetInst, CheckVal);

                        Changed = true;
			}
		    }
                 }
             }
           */

           if( CallInst *ClInst = dyn_cast<CallInst>(BI) ) 
             {
               DEBUG( std::cerr << "Handling Call instruction \n" );
               CheckVal = ClInst; // Get the value to be checked

               if ( ClInst->getCalledFunction() != NULL )
                 {
                  if (isTracerFunction(ClInst->getCalledFunction())) // Don't count and check the tracer/inv functions
                     continue;
                 }

               if( CheckType(CheckVal->getType()) && isa<Constant>(*CheckVal) == false )
                 { // If its a proper type for tracing and not a constant */ 
                   //ProgramPtId++;  // Update the id for the next program popint
                   if( invMap.count(ProgramPtId) != 0 ) // can be 0 when corresponding return/load/store instruction
                     {                                              // never executes
                      DEBUG( std::cerr << "Handling non-void signed/unsigned/FP returning Function \n" );
                      mydebug( CheckVal->getType() );

                      //PgmPtId = ConstantInt::get(IntTy, invMap[ProgramPtId]->ProgramPtId);       
                      CallInst *CI = insertCheckCall(ClInst, CheckVal);
                      ClInst->moveBefore(CI);

                      Changed = true;
		     }
		 }
             }
          
           else if( StoreInst *StInst = dyn_cast<StoreInst>(BI) ) 
             {
               DEBUG( std::cerr << "Handling store instruction \n" );
               CheckVal = StInst->getOperand(0);  // Get value operand               
               // Process Integer stores
               
               if( CheckType(CheckVal->getType()) && isa<Constant>(*CheckVal) == false )
                 {
		   //ProgramPtId++;  // Update the id for the next program popint
                  if( invMap.count(ProgramPtId) != 0 ) // can be 0 when corresponding return/load/store instruction
                    {                                              // never executes
                     DEBUG( std::cerr << "Handling signed/unsigned/FP stores \n" );
                     mydebug( CheckVal->getType() );

                     //PgmPtId = ConstantInt::get(IntTy, invMap[ProgramPtId]->ProgramPtId);       
                     CallInst *CI = insertCheckCall(StInst, CheckVal);
                     StInst->moveBefore(CI);  // For uniformity, move check call to after store

                     Changed = true;
		     }
		  }
             }

           else if( LoadInst *LdInst = dyn_cast<LoadInst>(BI) ) 
             {
               DEBUG( std::cerr << "Handling load instruction \n" );
               CheckVal = LdInst;  // Get value operand               
               // Process Integer stores
               
               if( CheckType(CheckVal->getType()) && isa<Constant>(*CheckVal) == false ) 
                 {
		  //ProgramPtId++;  // Update the id for the next program popint
		  //std::cerr << "Load type and constantness checked :" << invMap.count(ProgramPtId) << std::endl;
                  if( invMap.count(ProgramPtId) != 0 ) // can be 0 when corresponding return/load/store instruction
                    {                                              // never executes
                     DEBUG( std::cerr << "Handling signed/unsigned/FP loads \n" );
                     mydebug( CheckVal->getType() );    

                     //PgmPtId = ConstantInt::get(IntTy, invMap[ProgramPtId]->ProgramPtId);       
                     CallInst *CI = insertCheckCall(LdInst, CheckVal);
                     LdInst->moveBefore(CI);

                     Changed = true;
		     }
		  }
             }
	     
         }
     }  


  return Changed;
}

bool InvInsert::doFinalization(Module &M) {

  //
  // Create a global constructor function that will initialize the run-time.
  //
  Function * RuntimeCtor = createCtor (M);

  //
  // Insert the constructor into the list of global constructor functions.
  //
  insertIntoGlobalCtorList (RuntimeCtor);

  //
  // Indicate that we've changed the module.
  //
  return true;
}



/********************************************************/
/***************** Old code ************************/
/********************************************************/

/*

//  ProgramId Should be changed to key of the new hashing function
#define READ_INVARIANT(INPFILE , INVMAP , TYPE) \
        {                             \
         INPFILE >> INVMAP[InvIndex]->Count >>  INVMAP[InvIndex]->NoOfUpdation >>  INVMAP[InvIndex]->Change.TYPE##Change   \
                                          >>  INVMAP[InvIndex]->DetailedType >>  INVMAP[InvIndex]->InstName  ;             \
         INPFILE >> INVMAP[InvIndex]->ProgramPtId ;               \
         INPFILE >> fname >> INVMAP[InvIndex]->Min.TYPE##Min >> INVMAP[InvIndex]->Max.TYPE##Max ;   \
	}

void InvInsert::readInvariants(InvMap &iMap, std::ifstream *InpInvFile)
{
  int count, InvIndex;
  int j = 0;
  char fname[100];

  while( (*InpInvFile >> InvIndex) ) 
      {
        *InpInvFile >> count;
        for(j=0; j<count; j++)
           { // ***** Now count = 1. Use a different hashing function, if count > 1 *******
            iMap[InvIndex] = new Invariant ; 
	    *InpInvFile >> iMap[InvIndex]->Type ;

            if( !strcmp(iMap[InvIndex]->Type, "long") )  
               READ_INVARIANT(*InpInvFile, iMap, long)
            else if( !strcmp(iMap[InvIndex]->Type, "ulong") )  
               READ_INVARIANT(*InpInvFile, iMap, ulong)
            else if( !strcmp(iMap[InvIndex]->Type, "double") )  
	       READ_INVARIANT(*InpInvFile, iMap,long) // Reading as long to avoid truncation 

            iMap[InvIndex]->Fname = (char *) malloc( strlen(fname) + 1 );
            strcpy( iMap[InvIndex]->Fname , fname );
           }
      } 
  printInvariants(iMap);   
}

#define PRINT_INVARIANT(TYPE) \
           {                                                           \
            DEBUG( std::cerr << it->first << " " << it->second->Type << " " << it->second->Count << " " <<  it->second->NoOfUpdation << " " << \
                              it->second->Change.TYPE##Change << " " << it->second-> DetailedType << " " <<  it->second->InstName << "\n" ) ;  \
            DEBUG( std::cerr << it->second->ProgramPtId << " " << it->second->Fname << " " << it->second->Min.TYPE##Min << " " << it->second->Max.TYPE##Max << "\n" ) ; \
           }         

void InvInsert::printInvariants(InvMap &iMap)
{
  DEBUG( std::cerr << "Printing invariants\n" ) ; 
  for( InvMap::iterator it = iMap.begin(); it != iMap.end(); it++ )
     {
       if( !strcmp(it->second->Type,"long") )  
         PRINT_INVARIANT(long)
       else if( !strcmp(it->second->Type,"ulong") )  
         PRINT_INVARIANT(ulong)
       else if( !strcmp(it->second->Type,"double") )  
         PRINT_INVARIANT(long)  // printing as long to avoid truncation 
     }
  DEBUG( std::cerr << "Finished printing invariants\n" ) ; 
}



void InvInsert::scheduleInit(void)
{

}

*/
