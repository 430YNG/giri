<div id="content">
  <h2>[GSoC 2014] Giri: Dynamic Slicing in LLVM</h2>

  <p>Program slice[1] contains all statements in a program that directly or indirectly affect the value of a variable or instruction. We can further narrow down the notion of the <i>slice</i> to <i>dynamic program slice</i>. Unlike traditional slicing named static slicing which computes all statements that may have affected the value of a variable at a program point for any arbitrary execution of the program, the dynamic program slicing computes all statements that actually affect the value of a variable/instruction at a program point for a particular execution of the program with given input[2]. There are many applications from research and industry organizations which use (or could benefit from) dynamic slicing. For example, it has long been used in software debugging and testing. However, to the best of our knowledge, there is no publicly available dynamic slicing tool in either GCC or Open64.</p>

  <p><a href="http://web.engr.illinois.edu/~ssahoo2/" target="_blank">Swarup Kumar Sahoo</a>, <a href="http://www.bigw.org/~jcriswel" target="_blank">John Criswell</a>, Chase Geigle, and <a href="http://llvm.cs.uiuc.edu/~vadve/" target="_blank">Vikram Adve</a> use dynamic program slicing to filter/remove false positives from the candidate root causes for automated software fault localization[3]. They implemented the dynamic program slicing code, named Giri, in LLVM compiler infrastructure (version 3.1) for research purpose. It collects the trace of a user program execution and finally reports the dynamic slice of a given statement. It also maps LLVM intermediate representation (IR) statements to source code using the debug meta-data to report the dynamic slice in terms of source line numbers. To make the Giri up-to-date and robust for general use, the Giri code was further enhanced in several ways by <a href="http://pacman.cs.tsinghua.edu.cn/~liuml07" target="_blank">Mingliang Liu</a>, directed by Swarup. This work was sponsored by Google Summer of Code (GSoC) 2014.

  <h3>Dynamic Program Slicing</h3>
  <p>The following is an example program. Given the input <tt>10</tt> to this program from command line, the source line numbers affect the return value are: <tt>13, 20, 27, 40, 42, 44, 47</tt>. The line numbers <tt>13, 20</tt> are included due to control dependence, while line numbers <tt>27, 40, 42, 44, 47</tt> are included due to data dependence.</p>
  <pre><code>
	1:  #include &lt;math.h&gt;  
	2:  #include &lt;stdio.h&gt;  
	3:  #include &lt;stdlib.h&gt;  
	4:    
	5:  typedef struct result  
	6:  {  
	7:    int result;  
	8:    int count;  
	9:  } result_t;  
	10:    
	11:  void calc(int x, result_t *y, result_t *z)  
	12:  {  
	13:    if (x &lt; 0)  
	14:    {  
	15:      y-&gt;result = sqrt(x);  
	16:      y-&gt;count++;  
	17:      z-&gt;result = pow(2, x);  
	18:      z-&gt;count++;  
	19:    } else {  
	20:      if (x == 0)  
	21:      {  
	22:        y-&gt;result = sqrt(x * 2);  
	23:        y-&gt;count++;  
	24:        z-&gt;result = pow(3, x);  
	25:        z-&gt;count++;  
	26:      } else {  
	27:        y-&gt;result = sqrt(x * 3);  
	28:        y-&gt;count++;  
	29:        z-&gt;result = pow(4, x);  
	30:        z-&gt;count++;  
	31:      }  
	32:    }  
	33:  }  
	34:    
	35:  int main(int argc, char *argv[])  
	36:  {  
	37:    int x, ret;  
	38:    result_t y = {0, 0}, z = {0, 0};  
	39:    
	40:    x = atoi(argv[1]);  
	41:    
	42:    calc(x, &amp;y, &amp;z);  
	43:      
	44:    ret = printf("%d\n", y.result);  
	45:    printf("%d\n", z.result);  
	46:    
	47:    return ret;  
	48:  }  
  </code></pre>

  <p>The default starting point of slicing is the <tt>return</tt> instruction at the <tt>main</tt> function. Note that there is only one <tt>return</tt> when the main executes. Giri also supports two more ways to specify the starting criterion of the slice, which are source code line number and LLVM instruction number respectively. See the <a href="https://github.com/liuml07/giri/wiki/Example-Usage" target="_blank">example usage</a> for more information.</p>

  <h3>The Design of Giri</h3>
  <p>Giri handles both data-flow and control-flow dependences (optional) when computing the dynamic backwards slice. It has two phases. In the first pass named <i>tracing</i> pass, it instruments the code to record various runtime information in a trace file at run-time for all threads. In the second pass named <i>slicing</i> pass, it uses the execution trace to create a program dependence graph for computing dynamic slice. Giri takes advantage of the LLVM intermediate representation (IR), which is static single assignment (SSA) form, to reduce the size of the trace file.</p>

  <p>The tracing pass instruments code to record three different pieces of information: basic block exits, memory accesses and their addresses, and  function calls and returns. The slicing pass initializes a work list with the starting instruction (also called <i>criterion</i>) of slicing. For each dynamic value in the work list, the slicing pass computes both data-flow and control-flow dependences for it using program SSA form and trace. First, we compute all the dynamic instructions which influence the current dynamic value under consideration through direct flow of data values. Next, static control-dependence analysis is employed to determine which values or instructions can directly force the execution of the basic block to which this dynamic value belongs. Then, the slicing pass uses the trace records to find the most recent dynamic instance of those values or instructions which forces the execution of this dynamic value. The dynamic values computed by control or data dependence are added to the work list if not already processed earlier. The slicing pass does not stop until all dynamic values in the work list are processed. In the end, it reports the dynamic slice of the program execution from the slice starting point in terms of LLVM instructions as well as the source code line numbers.</p>

  <p>Since most instructions operate on SSA scalar values, we only refer to dynamic trace whenever needed. For example, we can get all the operands of an <tt>add</tt> instruction from the program SSA form without accessing the trace file. However, when we try to find all the <tt>store</tt> instructions which feed value to a <tt>load</tt> instruction, we need to scan the trace file since the data read by the <tt>load</tt> instruction may be written by many possible <tt>store</tt> instructions, which can only be determined accurately at runtime.</p>

  <p>To make the slicing pass thread aware, the runtime library writes the thread id (<tt>thread_t</tt> to each record indicating current thread performing that operation. The slicing pass checks the thread id when scanning the trace file for a given dynamic value or basic block.</p>

  <h3>Progress</h3>
  <p>Our goal of GSoC was to make the Giri code up-to-date with the latest LLVM version, improve its runtime performance, and/or reduce the tracing overhead. There are several things we did in this summer:</p>
  <ul> 
	<li> <b>Update the code to LLVM mainline.</b></li>
	<li> <b>Make the Giri run-time library thread safe and the slicing pass thread aware</b>. The trace records of all threads are written to a single file. In addition to other information, trace records also include the thread id (<tt>pthread_t</tt> which indicates the thread performing that particular operation. We use locks when we write trace records to the trace file in order to avoid race conditions.</li>
	<li> <b>Improve the Giri run-time performance.</b> We checked every call to function <tt>mmap</tt> as well as the parameters, and eliminated the useless ones to improve performance. For example, at the end of the tracing, it is not needed to re-<tt>mmap</tt> once all the trace records are synchronized to disk file. Giri now dynamically computes the cache size of trace records to hold in memory before flushing to disk.</li>
	<li> <b>Write dozens of unit tests and try more real programs.</b> Giri was able to handle few large real programs like Squid, Apache, MySQL before GSoC.  We added few more real programs to this set.  There is also a simple test framework which runs all the unit tests at the top level of <tt>giri/test/</tt> and report the results.  In the future development, we shall make sure all unit tests pass locally before submitting a patch to the code repository.</li>
	<li> <b>Reduce the trace size.</b> We truncate the trace file at the end of tracing according to its real size.</li>
	<li> <b>Write documents for the project.</b></li>
  </ul>

  <h3>Future Work</h3>
  <p>The following is the list of future work we are going to address in the next weeks. An updated list is maintained online at the <a href="https://github.com/liuml07/giri/wiki/TODO">Giri wiki page</a>.</p>
  <ul>
	<li> Improve the performance of locking mechanism of the Giri runtime.
	<li> Write more unit tests with complicated direct/indirect recursive function calls.</li>
	<li> Try more real world programs and add them to the <tt>test/</tt> directory.</li>
	<li> Try large test programs, e.g. nginx, squid, etc.</li>
	<li> Make Giri code useful for other platforms besides Linux, e.g. Mac OS X, Cygwin, and FreeBSD.</li>
	<li> Handle more special function calls, which are intrinsic LLVM instructions (like <tt>libc</tt> functions <tt>printf, scanf, sprintf</tt> etc.) in <tt>TracingNoGiri::visitSpecialCall()</tt>.</li>
	<li> Parallelize the code which writes the entry cache containing trace records to trace file and adds trace records to the entry cache.</li>
  </ul>

  <h3>Conclusion</h3>
  <p>As the first publicly available dynamic slicing tool, Giri was improved significantly during the GSoC. We updated the code to LLVM mainline, reduced the trace size, made it thread-aware, and improved the performance of its run-time. We have published our code at <a href="https://github.com/liuml07/giri">https://github.com/liuml07/giri</a>. The code is still under active development and pull requests are heavily welcome.</p>
  
  <div id="references">
	[1] M. Weiser. Program slicing. In ICSE, pages 439–449. IEEE, 1981.</br>
	[2] H AGRAWAL. Dynamic Program Slicing. In PLDI. ACM, 1990.</br>
	[3] Swarup Kumar Sahoo, John Criswell, Chase Geigle, and Vikram Adve. Using likely invariants for automated software fault localization. In ASPLOS’13, pages 139–152, New York, NY, USA, 2013. ACM.
  </div>
</div>
